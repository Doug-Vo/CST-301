import json
import requests
from bs4 import BeautifulSoup
from sumy.parsers.plaintext import PlaintextParser
from sumy.nlp.tokenizers import Tokenizer
from sumy.summarizers.lex_rank import LexRankSummarizer
def extract_classes_and_functions(ast_tree, imports):
    classes_and_functions = {}

    def traverse(node):
        if isinstance(node, dict):
            if "__class__" in node:
                if node["__class__"] == "MethodInvocation":
                    qualifier = node.get("qualifier")
                    if qualifier:
                        class_name = qualifier.split('.')[-1]  # Extract class name from the qualifier
                        class_name = imports.get(class_name, class_name)  # Replace object name with class name
                        method_name = node.get("member")
                        if class_name not in classes_and_functions:
                            classes_and_functions[class_name] = set()
                        classes_and_functions[class_name].add(method_name)
                # Traverse children recursively
                for key, value in node.items():
                    if key != "name":  # Skip "name" field
                        traverse(value)
        elif isinstance(node, list):
            for item in node:
                traverse(item)

    traverse(ast_tree)

    return classes_and_functions

def read_function_documentation(url, function):
    result = ""
    # Send a GET request to the URL
    response = requests.get(url)

    # Check if the request was successful
    if response.status_code == 200:
        # Parse the HTML content
        soup = BeautifulSoup(response.content, 'html.parser')

        # Extract the text content
        documentation_content = soup.find('name', id=function)
        if documentation_content:
            result += documentation_content.get_text(separator='')
        else:
            print("Java documentation content not found on this page.")
    else:
        print("Failed to retrieve Java documentation. Status code: {}".format(response.status_code))

    return result

def summarize_function(input_text):
    # Initialize the parser and tokenizer
    parser = PlaintextParser.from_string(input_text, Tokenizer('english'))

    # Initialize the LexRank summarizer
    summarizer = LexRankSummarizer()

    # Summarize the text
    summary = summarizer(parser.document, sentences_count=2)  # Adjust the number of sentences in the summary as needed
    file.write("\n" + "Summary:")
    for sentence in summary:
        file.write(str(sentence)+"\n")

def find_imported_class(ast_tree, variable_name):
    class_name = None

    def traverse(node):
        nonlocal class_name
        if isinstance(node, dict):
            if "__class__" in node:
                if node["__class__"] == "LocalVariableDeclaration":
                    for declarator in node.get("declarators", []):
                        if declarator.get("name") == variable_name:
                            type_node = node.get("type")
                            if type_node and "__class__" in type_node and type_node["__class__"] == "ReferenceType":
                                class_name = type_node.get("name")
                                return
            # Traverse children recursively
            for key, value in node.items():
                traverse(value)
        elif isinstance(node, list):
            for item in node:
                traverse(item)

    traverse(ast_tree)
    return class_name

# Read AST from JSON file
with open("ast.json", "r") as file:
    ast_tree = json.load(file)

# Extract imported classes
imports = {}
for item in ast_tree["imports"]:
    class_name = item["path"].split('.')[-1]
    imports[class_name] = item["path"]
print(imports)

classes_and_functions = extract_classes_and_functions(ast_tree, imports)

# Convert the dictionary to the desired format
result = [{'name': class_name, 'functions': functions} for class_name, functions in classes_and_functions.items()]

print(result)

with open("output.txt", "w") as file:
    for item in result:
        class_instance_name = item['name']
        functions = item['functions']
        for function_name in functions:
            # Find class name associated with the variable instance
            class_name = find_imported_class(ast_tree, class_instance_name)
            if class_name:
                print(class_name)
            else:
                print(f"No class name found for {class_instance_name}")
            url = f"https://docs.oracle.com/javase/8/docs/api/java/sql/{class_name}.html"
            function = function_name + "()"
            print(url)
            print(function)
            description = read_function_documentation(url, function_name)
            summarize_function(description)